'use strict'
var defaultOptions = { componentWillUnmount: !1 },
  forwardRefSymbol = Symbol.for('react.forward_ref'),
  pReduce = function(e, p, t) {
    return new Promise(function(r, o) {
      var i = e[Symbol.iterator](),
        u = 0
      !(function t(e) {
        var n = i.next()
        n.done
          ? r(e)
          : Promise.all([e, n.value])
              .then(function(e) {
                t(p(e[0], e[1], u++))
              })
              .catch(o)
      })(t)
    })
  },
  pMapSeries = function(e, r) {
    var o = []
    return pReduce(e, function(e, t, n) {
      return Promise.resolve(r(t, n)).then(function(e) {
        o.push(e)
      })
    }).then(function() {
      return o
    })
  },
  ensureChild = function e(t) {
    return t && 'function' == typeof t.render ? e(t.render()) : t
  },
  getChildren = function(e) {
    return e.props && e.props.children
      ? e.props.children
      : e.children
        ? e.children
        : void 0
  },
  getType = function(e) {
    return e.type || e.nodeName
  },
  getProps = function(e) {
    return e.props || e.attributes
  },
  isReactElement = function(e) {
    return !!getType(e)
  },
  isClassComponent = function(e) {
    return (
      e.prototype &&
      (e.prototype.render ||
        e.prototype.isReactComponent ||
        e.prototype.isPureReactComponent)
    )
  },
  isForwardRef = function(e) {
    return e.type && e.type.$$typeof === forwardRefSymbol
  },
  providesChildContext = function(e) {
    return !!e.getChildContext
  }
function reactTreeWalker(t, n, r) {
  var f =
    3 < arguments.length && void 0 !== arguments[3]
      ? arguments[3]
      : defaultOptions
  return new Promise(function(e, l) {
    var a = function() {
      try {
        return n.apply(void 0, arguments)
      } catch (e) {
        l(e)
      }
    }
    ;(function p(c, s) {
      if (Array.isArray(c))
        return Promise.all(
          c.map(function(e) {
            return p(e, s)
          }),
        )
      if (!c) return Promise.resolve()
      if ('string' == typeof c || 'number' == typeof c)
        return a(c, null, s), Promise.resolve()
      if (c.type) {
        var e = c.type._context || (c.type.Provider && c.type.Provider._context)
        if (
          e &&
          ('value' in c.props &&
            (c.type._context._currentValue = c.props.value),
          'function' == typeof c.props.children)
        ) {
          var t = c.props.children(e._currentValue)
          return p(t, s)
        }
      }
      return isReactElement(c)
        ? new Promise(function(i) {
            var e = function(r, e, t, o) {
              return Promise.resolve(a(c, e, t, o))
                .then(function(e) {
                  if (!1 !== e) {
                    var t = r(),
                      n = ensureChild(t)
                    if (n)
                      return Array.isArray(n)
                        ? pMapSeries(n, function(e) {
                            return e ? p(e, o) : Promise.resolve()
                          })
                            .then(i, l)
                            .catch(l)
                        : p(n, o)
                            .then(i, l)
                            .catch(l)
                  }
                })
                .catch(l)
            }
            if ('function' == typeof getType(c) || isForwardRef(c)) {
              var t = getType(c),
                n = Object.assign({}, t.defaultProps, getProps(c), {
                  children: getChildren(c),
                })
              if (isForwardRef(c))
                e(
                  function() {
                    return c.type.render(n)
                  },
                  null,
                  s,
                  s,
                ).then(i)
              else if (isClassComponent(t)) {
                var r = new t(n, s)
                if (
                  (Object.defineProperty(r, 'props', { value: r.props || n }),
                  (r.context = r.context || s),
                  (r.state = r.state || null),
                  (r.setState = function(e) {
                    'function' == typeof e &&
                      (e = e(r.state, r.props, r.context)),
                      (r.state = Object.assign({}, r.state, e))
                  }),
                  t.getDerivedStateFromProps)
                ) {
                  var o = t.getDerivedStateFromProps(r.props, r.state)
                  null !== o && (r.state = Object.assign({}, r.state, o))
                } else
                  r.UNSAFE_componentWillMount
                    ? r.UNSAFE_componentWillMount()
                    : r.componentWillMount && r.componentWillMount()
                var u = providesChildContext(r)
                  ? Object.assign({}, s, r.getChildContext())
                  : s
                e(
                  function() {
                    return r.render(r.props, r.state)
                  },
                  r,
                  s,
                  u,
                )
                  .then(function() {
                    f.componentWillUnmount &&
                      r.componentWillUnmount &&
                      r.componentWillUnmount()
                  })
                  .then(i)
              } else
                e(
                  function() {
                    return t(n, s)
                  },
                  null,
                  s,
                  s,
                ).then(i)
            } else
              e(
                function() {
                  return getChildren(c)
                },
                null,
                s,
                s,
              ).then(i)
          })
        : c.containerInfo &&
          c.children &&
          c.children.props &&
          Array.isArray(c.children.props.children)
          ? Promise.all(
              c.children.props.children.map(function(e) {
                return p(e, s)
              }),
            )
          : Promise.resolve()
    })(t, r).then(e, l)
  })
}
module.exports = reactTreeWalker
//# sourceMappingURL=react-tree-walker.min.js.map
